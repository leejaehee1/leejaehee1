# React Hooks 7일차: useRef, useContext, useReducer

## 학습 목표
- useRef를 사용하여 DOM 요소에 접근하고 값을 저장하는 방법을 배웁니다
- useContext를 활용하여 전역 상태를 관리하는 방법을 이해합니다
- useReducer로 복잡한 상태 로직을 체계적으로 관리하는 방법을 익힙니다

---

## 1. useRef 훅

### useRef란?
useRef는 **참조(reference)**를 만들어주는 훅입니다. 주로 두 가지 용도로 사용됩니다:
1. DOM 요소에 직접 접근하기
2. 리렌더링되지 않는 값 저장하기

### 기본 사용법

```javascript
import { useRef } from 'react';

function MyComponent() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>포커스 주기</button>
    </div>
  );
}
```

### useRef vs useState 차이점

| useRef | useState |
|--------|----------|
| 값이 변경되어도 리렌더링되지 않음 | 값이 변경되면 리렌더링됨 |
| `.current` 속성으로 접근 | 직접 접근 |
| 언제든지 변경 가능 | setter 함수로만 변경 |

### 실습 예제: 타이머 만들기

```javascript
import { useState, useRef } from 'react';

function Timer() {
  const [seconds, setSeconds] = useState(0);
  const intervalRef = useRef(null);
  
  const startTimer = () => {
    intervalRef.current = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);
  };
  
  const stopTimer = () => {
    clearInterval(intervalRef.current);
  };
  
  const resetTimer = () => {
    clearInterval(intervalRef.current);
    setSeconds(0);
  };
  
  return (
    <div>
      <h2>타이머: {seconds}초</h2>
      <button onClick={startTimer}>시작</button>
      <button onClick={stopTimer}>정지</button>
      <button onClick={resetTimer}>리셋</button>
    </div>
  );
}
```

---

## 2. useContext 훅

### useContext란?
useContext는 React의 Context API를 사용하여 **전역 상태**를 관리할 수 있게 해주는 훅입니다. props로 일일이 전달하지 않고도 컴포넌트 트리 어디서든 데이터에 접근할 수 있습니다.

### Context 생성하기

```javascript
import { createContext, useContext, useState } from 'react';

// 1. Context 생성
const UserContext = createContext();

// 2. Provider 컴포넌트 만들기
function UserProvider({ children }) {
  const [user, setUser] = useState({ name: '익명', age: 0 });
  
  return (
    <UserContext.Provider value={{ user, setUser }}>
      {children}
    </UserContext.Provider>
  );
}

// 3. useContext 사용하기
function UserProfile() {
  const { user, setUser } = useContext(UserContext);
  
  return (
    <div>
      <h2>사용자 정보</h2>
      <p>이름: {user.name}</p>
      <p>나이: {user.age}</p>
      <button onClick={() => setUser({ name: '김철수', age: 25 })}>
        정보 변경
      </button>
    </div>
  );
}

// 4. 앱에서 사용하기
function App() {
  return (
    <UserProvider>
      <UserProfile />
    </UserProvider>
  );
}
```

### 실습 예제: 테마 변경 시스템

```javascript
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

function Header() {
  const { theme, toggleTheme } = useContext(ThemeContext);
  
  return (
    <header style={{ 
      backgroundColor: theme === 'light' ? '#fff' : '#333',
      color: theme === 'light' ? '#333' : '#fff'
    }}>
      <h1>내 웹사이트</h1>
      <button onClick={toggleTheme}>
        {theme === 'light' ? '다크 모드' : '라이트 모드'}
      </button>
    </header>
  );
}

function Content() {
  const { theme } = useContext(ThemeContext);
  
  return (
    <main style={{ 
      backgroundColor: theme === 'light' ? '#f5f5f5' : '#222',
      color: theme === 'light' ? '#333' : '#fff'
    }}>
      <p>현재 테마: {theme}</p>
    </main>
  );
}
```

---

## 3. useReducer 훅

### useReducer란?
useReducer는 **복잡한 상태 로직**을 관리할 때 사용하는 훅입니다. useState의 대안으로, 상태 업데이트 로직을 컴포넌트 외부로 분리할 수 있습니다.

### 기본 구조

```javascript
import { useReducer } from 'react';

// 1. 초기 상태
const initialState = { count: 0 };

// 2. 리듀서 함수
function reducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    case 'RESET':
      return { count: 0 };
    default:
      return state;
  }
}

// 3. 컴포넌트에서 사용
function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  
  return (
    <div>
      <p>카운트: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>리셋</button>
    </div>
  );
}
```

### useReducer vs useState 언제 사용할까?

**useState를 사용할 때:**
- 간단한 상태 (문자열, 숫자, 불린)
- 상태 업데이트 로직이 단순함

**useReducer를 사용할 때:**
- 복잡한 상태 객체
- 여러 상태가 연관되어 있음
- 상태 업데이트 로직이 복잡함

### 실습 예제: 할 일 목록 관리

```javascript
import { useReducer, useState } from 'react';

const initialState = {
  todos: [],
  nextId: 1
};

function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: state.nextId,
            text: action.payload,
            completed: false
          }
        ],
        nextId: state.nextId + 1
      };
    
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        )
      };
    
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload)
      };
    
    default:
      return state;
  }
}

function TodoApp() {
  const [state, dispatch] = useReducer(todoReducer, initialState);
  const [inputValue, setInputValue] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (inputValue.trim()) {
      dispatch({ type: 'ADD_TODO', payload: inputValue });
      setInputValue('');
    }
  };
  
  return (
    <div>
      <h2>할 일 목록</h2>
      
      <form onSubmit={handleSubmit}>
        <input
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="새로운 할 일 입력"
        />
        <button type="submit">추가</button>
      </form>
      
      <ul>
        {state.todos.map(todo => (
          <li key={todo.id}>
            <span
              style={{
                textDecoration: todo.completed ? 'line-through' : 'none'
              }}
              onClick={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}
            >
              {todo.text}
            </span>
            <button 
              onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })}
            >
              삭제
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

---

## 4. 종합 실습: 쇼핑카트 만들기

세 가지 훅을 모두 활용한 쇼핑카트 예제입니다:

```javascript
import { createContext, useContext, useReducer, useRef } from 'react';

// Context 생성
const CartContext = createContext();

// 카트 리듀서
const cartReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      const existingItem = state.items.find(item => item.id === action.payload.id);
      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =>
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          )
        };
      }
      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }]
      };
    
    case 'REMOVE_ITEM':
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload)
      };
    
    case 'CLEAR_CART':
      return { ...state, items: [] };
    
    default:
      return state;
  }
};

// 카트 Provider
function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, { items: [] });
  
  return (
    <CartContext.Provider value={{ state, dispatch }}>
      {children}
    </CartContext.Provider>
  );
}

// 상품 목록 컴포넌트
function ProductList() {
  const { dispatch } = useContext(CartContext);
  const products = [
    { id: 1, name: '노트북', price: 1000000 },
    { id: 2, name: '마우스', price: 30000 },
    { id: 3, name: '키보드', price: 80000 }
  ];
  
  return (
    <div>
      <h2>상품 목록</h2>
      {products.map(product => (
        <div key={product.id}>
          <span>{product.name} - {product.price.toLocaleString()}원</span>
          <button onClick={() => dispatch({ type: 'ADD_ITEM', payload: product })}>
            장바구니에 추가
          </button>
        </div>
      ))}
    </div>
  );
}

// 장바구니 컴포넌트
function Cart() {
  const { state, dispatch } = useContext(CartContext);
  const cartRef = useRef(null);
  
  const scrollToCart = () => {
    cartRef.current.scrollIntoView({ behavior: 'smooth' });
  };
  
  const totalPrice = state.items.reduce(
    (total, item) => total + item.price * item.quantity,
    0
  );
  
  return (
    <div ref={cartRef}>
      <h2>장바구니</h2>
      {state.items.length === 0 ? (
        <p>장바구니가 비어있습니다.</p>
      ) : (
        <>
          {state.items.map(item => (
            <div key={item.id}>
              <span>{item.name} x {item.quantity} = {(item.price * item.quantity).toLocaleString()}원</span>
              <button onClick={() => dispatch({ type: 'REMOVE_ITEM', payload: item.id })}>
                제거
              </button>
            </div>
          ))}
          <h3>총액: {totalPrice.toLocaleString()}원</h3>
          <button onClick={() => dispatch({ type: 'CLEAR_CART' })}>
            장바구니 비우기
          </button>
        </>
      )}
      <button onClick={scrollToCart}>장바구니로 스크롤</button>
    </div>
  );
}

// 메인 앱
function ShoppingApp() {
  return (
    <CartProvider>
      <div>
        <ProductList />
        <Cart />
      </div>
    </CartProvider>
  );
}
```

---

## 5. 정리 및 베스트 프랙티스

### 각 훅의 핵심 포인트

**useRef:**
- DOM 조작이 필요할 때
- 리렌더링을 피하고 싶은 값 저장
- 타이머, 포커스 등에 유용

**useContext:**
- 전역 상태 관리
- Props drilling 방지
- 테마, 인증 정보 등에 적합

**useReducer:**
- 복잡한 상태 로직
- 여러 상태가 연관될 때
- 상태 업데이트 로직을 분리하고 싶을 때

### 주의사항

1. **useRef 남용 금지**: 대부분의 경우 선언적 방식이 더 좋습니다
2. **Context 과도한 사용 주의**: 성능에 영향을 줄 수 있습니다
3. **useReducer의 복잡성**: 간단한 상태는 useState가 더 적합합니다

---

## 6. 과제

다음 기능을 포함한 간단한 메모 앱을 만들어보세요:

1. **useRef**: 새 메모 입력 시 자동으로 포커스
2. **useContext**: 다크/라이트 테마 전환
3. **useReducer**: 메모 추가, 삭제, 수정 기능

### 기본 구조 힌트

```javascript
// 메모 리듀서
const memoReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_MEMO':
    case 'UPDATE_MEMO':
    case 'DELETE_MEMO':
    // 구현해보세요!
  }
};

// 테마 컨텍스트
const ThemeContext = createContext();

// 메모 앱 컴포넌트
function MemoApp() {
  const inputRef = useRef(null);
  // useReducer와 useContext 활용
}
```

---

## 7. 연습문제

### useRef 연습문제 (5문제)

**문제 1: 기본 DOM 접근**
텍스트 입력창과 버튼이 있는 컴포넌트를 만드세요. 버튼을 클릭하면 입력창에 자동으로 포커스가 가도록 구현하세요.

**요구사항:**
- `useRef`를 사용하여 input 요소에 접근
- 버튼 클릭 시 `focus()` 메서드 실행
- 컴포넌트 이름: `FocusInput`

**문제 2: 스크롤 이동**
헤더, 본문, 푸터 섹션이 있는 페이지를 만들고, 각 섹션으로 이동하는 네비게이션 버튼을 구현하세요.

**요구사항:**
- 각 섹션마다 `useRef` 사용
- 버튼 클릭 시 해당 섹션으로 부드럽게 스크롤 (`scrollIntoView({ behavior: 'smooth' })`)
- 헤더, 본문, 푸터 버튼 3개 필요

**문제 3: 이전 값 저장**
숫자를 입력받아 현재 값과 이전 값을 동시에 보여주는 컴포넌트를 만드세요.

**요구사항:**
- `useState`로 현재 값 관리
- `useRef`로 이전 값 저장 (리렌더링 방지)
- 입력창에 숫자 입력 시 "현재: X, 이전: Y" 형태로 표시

**문제 4: 렌더링 횟수 카운터**
컴포넌트가 몇 번 렌더링되었는지 카운트하는 기능을 구현하세요.

**요구사항:**
- `useRef`로 렌더링 횟수 저장
- 버튼 클릭 시 state 변경하여 강제 리렌더링
- 화면에 "렌더링 횟수: X번" 표시

**문제 5: 파일 업로드**
파일 선택 버튼을 클릭하면 숨겨진 파일 input이 활성화되는 커스텀 파일 업로드 컴포넌트를 만드세요.

**요구사항:**
- `useRef`로 hidden input 요소 접근
- 커스텀 버튼 클릭 시 `click()` 메서드 실행
- 파일 선택 시 파일명 표시

### useContext 연습문제 (5문제)

**문제 1: 언어 변경 시스템**
한국어/영어 언어 변경 시스템을 만드세요. 여러 컴포넌트에서 현재 언어에 따라 다른 텍스트를 표시해야 합니다.

**요구사항:**
- `LanguageContext` 생성
- `LanguageProvider`에서 현재 언어와 변경 함수 제공
- `Header`, `Content`, `Footer` 컴포넌트에서 각각 다른 텍스트 표시
- 언어 변경 버튼 구현

**문제 2: 사용자 인증 시스템**
로그인/로그아웃 기능이 있는 간단한 인증 시스템을 만드세요.

**요구사항:**
- `AuthContext` 생성
- 로그인 상태 (`isLoggedIn`), 사용자 정보 (`user`), 로그인/로그아웃 함수 제공
- `LoginForm` 컴포넌트: 로그인 전에만 표시
- `UserProfile` 컴포넌트: 로그인 후에만 표시
- `Navigation` 컴포넌트: 로그인 상태에 따라 다른 메뉴 표시

**문제 3: 알림 시스템**
전역 알림 메시지를 관리하는 시스템을 만드세요.

**요구사항:**
- `NotificationContext` 생성
- 알림 목록 (`notifications`) 및 추가/제거 함수 제공
- 알림 타입: `success`, `error`, `warning`, `info`
- 3초 후 자동으로 알림 제거
- 여러 컴포넌트에서 알림 추가 가능

**문제 4: 폰트 크기 설정**
사용자가 웹사이트의 폰트 크기를 조절할 수 있는 접근성 기능을 만드세요.

**요구사항:**
- `FontSizeContext` 생성
- 폰트 크기 옵션: `small`, `medium`, `large`
- 모든 텍스트 요소에 폰트 크기 적용
- 폰트 크기 변경 버튼 3개 구현

**문제 5: 장바구니 개수 표시**
간단한 상품 목록과 장바구니 아이콘에 개수를 표시하는 시스템을 만드세요.

**요구사항:**
- `CartContext` 생성
- 장바구니 아이템 목록과 추가/제거 함수 제공
- `ProductList`: 상품 목록과 "장바구니 추가" 버튼
- `CartIcon`: 장바구니 아이콘과 아이템 개수 표시
- 같은 상품 추가 시 수량 증가

### useReducer 연습문제 (5문제)

**문제 1: 계산기**
기본적인 사칙연산 계산기를 만드세요.

**요구사항:**
- 초기 상태: `{ display: '0', previousValue: null, operation: null, waitingForOperand: false }`
- 액션 타입: `INPUT_DIGIT`, `INPUT_OPERATOR`, `CALCULATE`, `CLEAR`
- 연산자: `+`, `-`, `*`, `/`
- 화면에 현재 값과 버튼들 표시

**문제 2: 게시판 관리**
게시글을 추가, 수정, 삭제할 수 있는 간단한 게시판을 만드세요.

**요구사항:**
- 초기 상태: `{ posts: [], nextId: 1, editingId: null }`
- 액션 타입: `ADD_POST`, `UPDATE_POST`, `DELETE_POST`, `START_EDIT`, `CANCEL_EDIT`
- 게시글 구조: `{ id, title, content, createdAt }`
- 수정 모드와 읽기 모드 전환

**문제 3: 퀴즈 앱**
객관식 퀴즈를 풀 수 있는 앱을 만드세요.

**요구사항:**
- 초기 상태: `{ currentQuestion: 0, score: 0, answers: [], isFinished: false }`
- 액션 타입: `ANSWER_QUESTION`, `NEXT_QUESTION`, `FINISH_QUIZ`, `RESET_QUIZ`
- 문제 배열을 props로 받음
- 점수 계산 및 결과 표시

**문제 4: 폼 유효성 검사**
회원가입 폼의 유효성 검사를 `useReducer`로 관리하세요.

**요구사항:**
- 초기 상태: `{ values: {}, errors: {}, touched: {} }`
- 액션 타입: `SET_FIELD`, `SET_ERROR`, `SET_TOUCHED`, `RESET_FORM`
- 필드: `username`, `email`, `password`, `confirmPassword`
- 유효성 검사 규칙 적용

**문제 5: 음악 플레이어**
간단한 음악 플레이어의 상태를 관리하세요.

**요구사항:**
- 초기 상태: `{ playlist: [], currentTrack: 0, isPlaying: false, volume: 50, shuffle: false, repeat: 'none' }`
- 액션 타입: `PLAY`, `PAUSE`, `NEXT_TRACK`, `PREVIOUS_TRACK`, `SET_VOLUME`, `TOGGLE_SHUFFLE`, `SET_REPEAT`
- repeat 옵션: `'none'`, `'one'`, `'all'`
- 플레이리스트 끝에서 다음 곡 처리

---

## 8. 정답

### useRef 정답

**정답 1: 기본 DOM 접근**
```javascript
import { useRef } from 'react';

function FocusInput() {
  const inputRef = useRef(null);
  
  const handleFocus = () => {
    inputRef.current.focus();
  };
  
  return (
    <div>
      <input ref={inputRef} type="text" placeholder="여기에 입력하세요" />
      <button onClick={handleFocus}>포커스 주기</button>
    </div>
  );
}
```

**정답 2: 스크롤 이동**
```javascript
import { useRef } from 'react';

function ScrollPage() {
  const headerRef = useRef(null);
  const contentRef = useRef(null);
  const footerRef = useRef(null);
  
  const scrollToSection = (ref) => {
    ref.current.scrollIntoView({ behavior: 'smooth' });
  };
  
  return (
    <div>
      <nav style={{ position: 'fixed', top: 0, background: '#fff', padding: '10px' }}>
        <button onClick={() => scrollToSection(headerRef)}>헤더로</button>
        <button onClick={() => scrollToSection(contentRef)}>본문으로</button>
        <button onClick={() => scrollToSection(footerRef)}>푸터로</button>
      </nav>
      
      <div ref={headerRef} style={{ height: '100vh', background: '#f0f0f0', paddingTop: '50px' }}>
        <h1>헤더 섹션</h1>
      </div>
      
      <div ref={contentRef} style={{ height: '100vh', background: '#e0e0e0' }}>
        <h2>본문 섹션</h2>
      </div>
      
      <div ref={footerRef} style={{ height: '100vh', background: '#d0d0d0' }}>
        <h3>푸터 섹션</h3>
      </div>
    </div>
  );
}
```

**정답 3: 이전 값 저장**
```javascript
import { useState, useRef, useEffect } from 'react';

function PreviousValue() {
  const [currentValue, setCurrentValue] = useState(0);
  const previousValueRef = useRef(0);
  
  useEffect(() => {
    previousValueRef.current = currentValue;
  });
  
  return (
    <div>
      <input
        type="number"
        value={currentValue}
        onChange={(e) => setCurrentValue(Number(e.target.value))}
      />
      <p>현재: {currentValue}, 이전: {previousValueRef.current}</p>
    </div>
  );
}
```

**정답 4: 렌더링 횟수 카운터**
```javascript
import { useState, useRef, useEffect } from 'react';

function RenderCounter() {
  const [count, setCount] = useState(0);
  const renderCountRef = useRef(0);
  
  useEffect(() => {
    renderCountRef.current += 1;
  });
  
  return (
    <div>
      <p>렌더링 횟수: {renderCountRef.current}번</p>
      <button onClick={() => setCount(count + 1)}>리렌더링 ({count})</button>
    </div>
  );
}
```

**정답 5: 파일 업로드**
```javascript
import { useRef, useState } from 'react';

function FileUpload() {
  const fileInputRef = useRef(null);
  const [fileName, setFileName] = useState('');
  
  const handleButtonClick = () => {
    fileInputRef.current.click();
  };
  
  const handleFileChange = (e) => {
    const file = e.target.files[0];
    setFileName(file ? file.name : '');
  };
  
  return (
    <div>
      <input
        ref={fileInputRef}
        type="file"
        style={{ display: 'none' }}
        onChange={handleFileChange}
      />
      <button onClick={handleButtonClick}>파일 선택</button>
      {fileName && <p>선택된 파일: {fileName}</p>}
    </div>
  );
}
```

### useContext 정답

**정답 1: 언어 변경 시스템**
```javascript
import { createContext, useContext, useState } from 'react';

const LanguageContext = createContext();

const translations = {
  ko: {
    header: '안녕하세요',
    content: '내용입니다',
    footer: '푸터입니다',
    switchLang: '언어 변경'
  },
  en: {
    header: 'Hello',
    content: 'This is content',
    footer: 'This is footer',
    switchLang: 'Switch Language'
  }
};

function LanguageProvider({ children }) {
  const [language, setLanguage] = useState('ko');
  
  const toggleLanguage = () => {
    setLanguage(prev => prev === 'ko' ? 'en' : 'ko');
  };
  
  return (
    <LanguageContext.Provider value={{ language, toggleLanguage, translations: translations[language] }}>
      {children}
    </LanguageContext.Provider>
  );
}

function Header() {
  const { translations, toggleLanguage } = useContext(LanguageContext);
  
  return (
    <header>
      <h1>{translations.header}</h1>
      <button onClick={toggleLanguage}>{translations.switchLang}</button>
    </header>
  );
}

function Content() {
  const { translations } = useContext(LanguageContext);
  
  return (
    <main>
      <p>{translations.content}</p>
    </main>
  );
}

function Footer() {
  const { translations } = useContext(LanguageContext);
  
  return (
    <footer>
      <p>{translations.footer}</p>
    </footer>
  );
}

function App() {
  return (
    <LanguageProvider>
      <Header />
      <Content />
      <Footer />
    </LanguageProvider>
  );
}
```

**정답 2: 사용자 인증 시스템**
```javascript
import { createContext, useContext, useState } from 'react';

const AuthContext = createContext();

function AuthProvider({ children }) {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const [user, setUser] = useState(null);
  
  const login = (username) => {
    setUser({ username });
    setIsLoggedIn(true);
  };
  
  const logout = () => {
    setUser(null);
    setIsLoggedIn(false);
  };
  
  return (
    <AuthContext.Provider value={{ isLoggedIn, user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

function LoginForm() {
  const { login } = useContext(AuthContext);
  const [username, setUsername] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (username.trim()) {
      login(username);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        placeholder="사용자명"
      />
      <button type="submit">로그인</button>
    </form>
  );
}

function UserProfile() {
  const { user, logout } = useContext(AuthContext);
  
  return (
    <div>
      <p>안녕하세요, {user.username}님!</p>
      <button onClick={logout}>로그아웃</button>
    </div>
  );
}

function Navigation() {
  const { isLoggedIn } = useContext(AuthContext);
  
  return (
    <nav>
      <a href="/">홈</a>
      {isLoggedIn ? (
        <>
          <a href="/profile">프로필</a>
          <a href="/dashboard">대시보드</a>
        </>
      ) : (
        <a href="/login">로그인</a>
      )}
    </nav>
  );
}

function App() {
  const { isLoggedIn } = useContext(AuthContext);
  
  return (
    <AuthProvider>
      <Navigation />
      {isLoggedIn ? <UserProfile /> : <LoginForm />}
    </AuthProvider>
  );
}
```

**정답 3: 알림 시스템**
```javascript
import { createContext, useContext, useState, useEffect } from 'react';

const NotificationContext = createContext();

function NotificationProvider({ children }) {
  const [notifications, setNotifications] = useState([]);
  
  const addNotification = (message, type = 'info') => {
    const id = Date.now();
    setNotifications(prev => [...prev, { id, message, type }]);
    
    setTimeout(() => {
      removeNotification(id);
    }, 3000);
  };
  
  const removeNotification = (id) => {
    setNotifications(prev => prev.filter(notification => notification.id !== id));
  };
  
  return (
    <NotificationContext.Provider value={{ notifications, addNotification, removeNotification }}>
      {children}
    </NotificationContext.Provider>
  );
}

function NotificationList() {
  const { notifications, removeNotification } = useContext(NotificationContext);
  
  return (
    <div style={{ position: 'fixed', top: 20, right: 20, zIndex: 1000 }}>
      {notifications.map(notification => (
        <div
          key={notification.id}
          style={{
            padding: '10px',
            margin: '5px 0',
            borderRadius: '5px',
            backgroundColor: {
              success: '#d4edda',
              error: '#f8d7da',
              warning: '#fff3cd',
              info: '#d1ecf1'
            }[notification.type]
          }}
        >
          {notification.message}
          <button onClick={() => removeNotification(notification.id)}>×</button>
        </div>
      ))}
    </div>
  );
}

function TestButtons() {
  const { addNotification } = useContext(NotificationContext);
  
  return (
    <div>
      <button onClick={() => addNotification('성공했습니다!', 'success')}>
        성공 알림
      </button>
      <button onClick={() => addNotification('오류가 발생했습니다!', 'error')}>
        오류 알림
      </button>
      <button onClick={() => addNotification('주의하세요!', 'warning')}>
        경고 알림
      </button>
      <button onClick={() => addNotification('정보입니다.', 'info')}>
        정보 알림
      </button>
    </div>
  );
}

function App() {
  return (
    <NotificationProvider>
      <TestButtons />
      <NotificationList />
    </NotificationProvider>
  );
}
```

**정답 4: 폰트 크기 설정**
```javascript
import { createContext, useContext, useState } from 'react';

const FontSizeContext = createContext();

function FontSizeProvider({ children }) {
  const [fontSize, setFontSize] = useState('medium');
  
  const fontSizes = {
    small: '14px',
    medium: '16px',
    large: '20px'
  };
  
  return (
    <FontSizeContext.Provider value={{ fontSize, setFontSize, fontSizes }}>
      <div style={{ fontSize: fontSizes[fontSize] }}>
        {children}
      </div>
    </FontSizeContext.Provider>
  );
}

function FontSizeControls() {
  const { fontSize, setFontSize } = useContext(FontSizeContext);
  
  return (
    <div>
      <h3>폰트 크기 설정</h3>
      <button 
        onClick={() => setFontSize('small')}
        style={{ backgroundColor: fontSize === 'small' ? '#ccc' : 'white' }}
      >
        작게
      </button>
      <button 
        onClick={() => setFontSize('medium')}
        style={{ backgroundColor: fontSize === 'medium' ? '#ccc' : 'white' }}
      >
        보통
      </button>
      <button 
        onClick={() => setFontSize('large')}
        style={{ backgroundColor: fontSize === 'large' ? '#ccc' : 'white' }}
      >
        크게
      </button>
    </div>
  );
}

function SampleContent() {
  return (
    <div>
      <h1>제목입니다</h1>
      <p>이것은 샘플 텍스트입니다. 폰트 크기가 적용되는 것을 확인할 수 있습니다.</p>
      <p>모든 텍스트 요소에 폰트 크기 설정이 적용됩니다.</p>
    </div>
  );
}

function App() {
  return (
    <FontSizeProvider>
      <FontSizeControls />
      <SampleContent />
    </FontSizeProvider>
  );
}
```

**정답 5: 장바구니 개수 표시**
```javascript
import { createContext, useContext, useState } from 'react';

const CartContext = createContext();

function CartProvider({ children }) {
  const [cartItems, setCartItems] = useState([]);
  
  const addToCart = (product) => {
    setCartItems(prev => {
      const existingItem = prev.find(item => item.id === product.id);
      if (existingItem) {
        return prev.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }
      return [...prev, { ...product, quantity: 1 }];
    });
  };
  
  const removeFromCart = (productId) => {
    setCartItems(prev => prev.filter(item => item.id !== productId));
  };
  
  const getTotalItems = () => {
    return cartItems.reduce((total, item) => total + item.quantity, 0);
  };
  
  return (
    <CartContext.Provider value={{ cartItems, addToCart, removeFromCart, getTotalItems }}>
      {children}
    </CartContext.Provider>
  );
}

function ProductList() {
  const { addToCart } = useContext(CartContext);
  
  const products = [
    { id: 1, name: '사과', price: 1000 },
    { id: 2, name: '바나나', price: 2000 },
    { id: 3, name: '오렌지', price: 1500 }
  ];
  
  return (
    <div>
      <h2>상품 목록</h2>
      {products.map(product => (
        <div key={product.id} style={{ margin: '10px 0' }}>
          <span>{product.name} - {product.price}원</span>
          <button onClick={() => addToCart(product)}>장바구니 추가</button>
        </div>
      ))}
    </div>
  );
}

function CartIcon() {
  const { getTotalItems } = useContext(CartContext);
  
  return (
    <div style={{ position: 'fixed', top: 20, right: 20, fontSize: '24px' }}>
      🛒 <span style={{ backgroundColor: 'red', color: 'white', borderRadius: '50%', padding: '2px 6px' }}>
        {getTotalItems()}
      </span>
    </div>
  );
}

function App() {
  return (
    <CartProvider>
      <CartIcon />
      <ProductList />
    </CartProvider>
  );
}
```

### useReducer 정답

**정답 1: 계산기**
```javascript
import { useReducer } from 'react';

const initialState = {
  display: '0',
  previousValue: null,
  operation: null,
  waitingForOperand: false
};

function calculatorReducer(state, action) {
  switch (action.type) {
    case 'INPUT_DIGIT':
      if (state.waitingForOperand) {
        return {
          ...state,
          display: String(action.digit),
          waitingForOperand: false
        };
      }
      return {
        ...state,
        display: state.display === '0' ? String(action.digit) : state.display + action.digit
      };
    
    case 'INPUT_OPERATOR':
      const inputValue = parseFloat(state.display);
      
      if (state.previousValue === null) {
        return {
          ...state,
          previousValue: inputValue,
          operation: action.operator,
          waitingForOperand: true
        };
      }
      
      if (state.operation) {
        const currentValue = state.previousValue || 0;
        const newValue = calculate(currentValue, inputValue, state.operation);
        
        return {
          ...state,
          display: String(newValue),
          previousValue: newValue,
          operation: action.operator,
          waitingForOperand: true
        };
      }
      
      return state;
    
    case 'CALCULATE':
      const prev = state.previousValue;
      const current = parseFloat(state.display);
      
      if (prev !== null && state.operation) {
        const result = calculate(prev, current, state.operation);
        return {
          ...state,
          display: String(result),
          previousValue: null,
          operation: null,
          waitingForOperand: true
        };
      }
      
      return state;
    
    case 'CLEAR':
      return initialState;
    
    default:
      return state;
  }
}

function calculate(firstValue, secondValue, operation) {
  switch (operation) {
    case '+':
      return firstValue + secondValue;
    case '-':
      return firstValue - secondValue;
    case '*':
      return firstValue * secondValue;
    case '/':
      return firstValue / secondValue;
    default:
      return secondValue;
  }
}

function Calculator() {
  const [state, dispatch] = useReducer(calculatorReducer, initialState);
  
  const inputDigit = (digit) => {
    dispatch({ type: 'INPUT_DIGIT', digit });
  };
  
  const inputOperator = (operator) => {
    dispatch({ type: 'INPUT_OPERATOR', operator });
  };
  
  const calculate = () => {
    dispatch({ type: 'CALCULATE' });
  };
  
  const clear = () => {
    dispatch({ type: 'CLEAR' });
  };
  
  return (
    <div>
      <div style={{ fontSize: '24px', padding: '10px', border: '1px solid #ccc' }}>
        {state.display}
      </div>
      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '5px', marginTop: '10px' }}>
        <button onClick={clear}>C</button>
        <button onClick={() => inputOperator('/')}>/</button>
        <button onClick={() => inputOperator('*')}>*</button>
        <button onClick={() => inputOperator('-')}>-</button>
        
        <button onClick={() => inputDigit(7)}>7</button>
        <button onClick={() => inputDigit(8)}>8</button>
        <button onClick={() => inputDigit(9)}>9</button>
        <button onClick={() => inputOperator('+')} rowSpan={2}>+</button>
        
        <button onClick={() => inputDigit(4)}>4</button>
        <button onClick={() => inputDigit(5)}>5</button>
        <button onClick={() => inputDigit(6)}>6</button>
        
        <button onClick={() => inputDigit(1)}>1</button>
        <button onClick={() => inputDigit(2)}>2</button>
        <button onClick={() => inputDigit(3)}>3</button>
        <button onClick={calculate} rowSpan={2}>=</button>
        
        <button onClick={() => inputDigit(0)} colSpan={2}>0</button>
        <button onClick={() => inputDigit('.')}>.</button>
      </div>
    </div>
  );
}
```

**정답 2: 게시판 관리**
```javascript
import { useReducer, useState } from 'react';

const initialState = {
  posts: [],
  nextId: 1,
  editingId: null
};

function postsReducer(state, action) {
  switch (action.type) {
    case 'ADD_POST':
      return {
        ...state,
        posts: [
          ...state.posts,
          {
            id: state.nextId,
            title: action.payload.title,
            content: action.payload.content,
            createdAt: new Date().toLocaleString()
          }
        ],
        nextId: state.nextId + 1
      };
    
    case 'UPDATE_POST':
      return {
        ...state,
        posts: state.posts.map(post =>
          post.id === action.payload.id
            ? { ...post, title: action.payload.title, content: action.payload.content }
            : post
        ),
        editingId: null
      };
    
    case 'DELETE_POST':
      return {
        ...state,
        posts: state.posts.filter(post => post.id !== action.payload)
      };
    
    case 'START_EDIT':
      return {
        ...state,
        editingId: action.payload
      };
    
    case 'CANCEL_EDIT':
      return {
        ...state,
        editingId: null
      };
    
    default:
      return state;
  }
}

function Board() {
  const [state, dispatch] = useReducer(postsReducer, initialState);
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (title.trim() && content.trim()) {
      if (state.editingId) {
        dispatch({
          type: 'UPDATE_POST',
          payload: { id: state.editingId, title, content }
        });
      } else {
        dispatch({
          type: 'ADD_POST',
          payload: { title, content }
        });
      }
      setTitle('');
      setContent('');
    }
  };
  
  const startEdit = (post) => {
    dispatch({ type: 'START_EDIT', payload: post.id });
    setTitle(post.title);
    setContent(post.content);
  };
  
  const cancelEdit = () => {
    dispatch({ type: 'CANCEL_EDIT' });
    setTitle('');
    setContent('');
  };
  
  return (
    <div>
      <h2>게시판</h2>
      
      <form onSubmit={handleSubmit}>
        <div>
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder="제목"
            required
          />
        </div>
        <div>
          <textarea
            value={content}
            onChange={(e) => setContent(e.target.value)}
            placeholder="내용"
            required
          />
        </div>
        <button type="submit">
          {state.editingId ? '수정' : '작성'}
        </button>
        {state.editingId && (
          <button type="button" onClick={cancelEdit}>취소</button>
        )}
      </form>
      
      <div>
        {state.posts.map(post => (
          <div key={post.id} style={{ border: '1px solid #ccc', margin: '10px 0', padding: '10px' }}>
            <h3>{post.title}</h3>
            <p>{post.content}</p>
            <small>{post.createdAt}</small>
            <div>
              <button onClick={() => startEdit(post)}>수정</button>
              <button onClick={() => dispatch({ type: 'DELETE_POST', payload: post.id })}>
                삭제
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

**정답 3: 퀴즈 앱**
```javascript
import { useReducer } from 'react';

const questions = [
  {
    question: "React에서 상태를 관리하는 훅은?",
    options: ["useState", "useEffect", "useContext", "useRef"],
    correct: 0
  },
  {
    question: "JavaScript에서 배열의 마지막 요소를 제거하는 메서드는?",
    options: ["push()", "pop()", "shift()", "unshift()"],
    correct: 1
  },
  {
    question: "HTML에서 링크를 만드는 태그는?",
    options: ["<link>", "<a>", "<url>", "<href>"],
    correct: 1
  }
];

const initialState = {
  currentQuestion: 0,
  score: 0,
  answers: [],
  isFinished: false
};

function quizReducer(state, action) {
  switch (action.type) {
    case 'ANSWER_QUESTION':
      const newAnswers = [...state.answers, action.payload];
      const isCorrect = action.payload === questions[state.currentQuestion].correct;
      
      return {
        ...state,
        answers: newAnswers,
        score: isCorrect ? state.score + 1 : state.score
      };
    
    case 'NEXT_QUESTION':
      return {
        ...state,
        currentQuestion: state.currentQuestion + 1
      };
    
    case 'FINISH_QUIZ':
      return {
        ...state,
        isFinished: true
      };
    
    case 'RESET_QUIZ':
      return initialState;
    
    default:
      return state;
  }
}

function Quiz() {
  const [state, dispatch] = useReducer(quizReducer, initialState);
  
  const handleAnswer = (answerIndex) => {
    dispatch({ type: 'ANSWER_QUESTION', payload: answerIndex });
    
    if (state.currentQuestion < questions.length - 1) {
      setTimeout(() => {
        dispatch({ type: 'NEXT_QUESTION' });
      }, 1000);
    } else {
      setTimeout(() => {
        dispatch({ type: 'FINISH_QUIZ' });
      }, 1000);
    }
  };
  
  const resetQuiz = () => {
    dispatch({ type: 'RESET_QUIZ' });
  };
  
  if (state.isFinished) {
    return (
      <div>
        <h2>퀴즈 완료!</h2>
        <p>점수: {state.score}/{questions.length}</p>
        <p>정답률: {Math.round((state.score / questions.length) * 100)}%</p>
        <button onClick={resetQuiz}>다시 시작</button>
      </div>
    );
  }
  
  const currentQ = questions[state.currentQuestion];
  const hasAnswered = state.answers.length > state.currentQuestion;
  
  return (
    <div>
      <h2>퀴즈 ({state.currentQuestion + 1}/{questions.length})</h2>
      <h3>{currentQ.question}</h3>
      
      <div>
        {currentQ.options.map((option, index) => (
          <button
            key={index}
            onClick={() => handleAnswer(index)}
            disabled={hasAnswered}
            style={{
              display: 'block',
              margin: '10px 0',
              padding: '10px',
              backgroundColor: hasAnswered
                ? index === currentQ.correct
                  ? '#d4edda'
                  : index === state.answers[state.currentQuestion]
                  ? '#f8d7da'
                  : '#f8f9fa'
                : '#f8f9fa'
            }}
          >
            {option}
          </button>
        ))}
      </div>
      
      {hasAnswered && (
        <p>
          {state.answers[state.currentQuestion] === currentQ.correct
            ? '정답입니다!'
            : `오답입니다. 정답은 "${currentQ.options[currentQ.correct]}"입니다.`}
        </p>
      )}
    </div>
  );
}
```

**정답 4: 폼 유효성 검사**
```javascript
import { useReducer } from 'react';

const initialState = {
  values: {
    username: '',
    email: '',
    password: '',
    confirmPassword: ''
  },
  errors: {},
  touched: {}
};

function formReducer(state, action) {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        values: {
          ...state.values,
          [action.field]: action.value
        }
      };
    
    case 'SET_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: action.error
        }
      };
    
    case 'SET_TOUCHED':
      return {
        ...state,
        touched: {
          ...state.touched,
          [action.field]: true
        }
      };
    
    case 'RESET_FORM':
      return initialState;
    
    default:
      return state;
  }
}

function validateField(field, value, allValues) {
  switch (field) {
    case 'username':
      if (!value) return '사용자명을 입력해주세요.';
      if (value.length < 3) return '사용자명은 3자 이상이어야 합니다.';
      return '';
    
    case 'email':
      if (!value) return '이메일을 입력해주세요.';
      if (!/\S+@\S+\.\S+/.test(value)) return '올바른 이메일 형식이 아닙니다.';
      return '';
    
    case 'password':
      if (!value) return '비밀번호를 입력해주세요.';
      if (value.length < 6) return '비밀번호는 6자 이상이어야 합니다.';
      return '';
    
    case 'confirmPassword':
      if (!value) return '비밀번호 확인을 입력해주세요.';
      if (value !== allValues.password) return '비밀번호가 일치하지 않습니다.';
      return '';
    
    default:
      return '';
  }
}

function SignupForm() {
  const [state, dispatch] = useReducer(formReducer, initialState);
  
  const handleChange = (field, value) => {
    dispatch({ type: 'SET_FIELD', field, value });
    
    // 유효성 검사
    const error = validateField(field, value, { ...state.values, [field]: value });
    dispatch({ type: 'SET_ERROR', field, error });
  };
  
  const handleBlur = (field) => {
    dispatch({ type: 'SET_TOUCHED', field });
  };
  
  const handleSubmit = (e) => {
    e.preventDefault();
    
    // 모든 필드를 touched로 설정
    Object.keys(state.values).forEach(field => {
      dispatch({ type: 'SET_TOUCHED', field });
    });
    
    // 유효성 검사
    const hasErrors = Object.keys(state.values).some(field => {
      const error = validateField(field, state.values[field], state.values);
      if (error) {
        dispatch({ type: 'SET_ERROR', field, error });
        return true;
      }
      return false;
    });
    
    if (!hasErrors) {
      alert('회원가입이 완료되었습니다!');
      dispatch({ type: 'RESET_FORM' });
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <h2>회원가입</h2>
      
      <div>
        <label>사용자명:</label>
        <input
          type="text"
          value={state.values.username}
          onChange={(e) => handleChange('username', e.target.value)}
          onBlur={() => handleBlur('username')}
        />
        {state.touched.username && state.errors.username && (
          <span style={{ color: 'red' }}>{state.errors.username}</span>
        )}
      </div>
      
      <div>
        <label>이메일:</label>
        <input
          type="email"
          value={state.values.email}
          onChange={(e) => handleChange('email', e.target.value)}
          onBlur={() => handleBlur('email')}
        />
        {state.touched.email && state.errors.email && (
          <span style={{ color: 'red' }}>{state.errors.email}</span>
        )}
      </div>
      
      <div>
        <label>비밀번호:</label>
        <input
          type="password"
          value={state.values.password}
          onChange={(e) => handleChange('password', e.target.value)}
          onBlur={() => handleBlur('password')}
        />
        {state.touched.password && state.errors.password && (
          <span style={{ color: 'red' }}>{state.errors.password}</span>
        )}
      </div>
      
      <div>
        <label>비밀번호 확인:</label>
        <input
          type="password"
          value={state.values.confirmPassword}
          onChange={(e) => handleChange('confirmPassword', e.target.value)}
          onBlur={() => handleBlur('confirmPassword')}
        />
        {state.touched.confirmPassword && state.errors.confirmPassword && (
          <span style={{ color: 'red' }}>{state.errors.confirmPassword}</span>
        )}
      </div>
      
      <button type="submit">회원가입</button>
    </form>
  );
}
```

**정답 5: 음악 플레이어**
```javascript
import { useReducer } from 'react';

const playlist = [
  { id: 1, title: '노래 1', artist: '가수 1' },
  { id: 2, title: '노래 2', artist: '가수 2' },
  { id: 3, title: '노래 3', artist: '가수 3' },
  { id: 4, title: '노래 4', artist: '가수 4' }
];

const initialState = {
  playlist,
  currentTrack: 0,
  isPlaying: false,
  volume: 50,
  shuffle: false,
  repeat: 'none' // 'none', 'one', 'all'
};

function playerReducer(state, action) {
  switch (action.type) {
    case 'PLAY':
      return {
        ...state,
        isPlaying: true
      };
    
    case 'PAUSE':
      return {
        ...state,
        isPlaying: false
      };
    
    case 'NEXT_TRACK':
      let nextTrack;
      if (state.shuffle) {
        nextTrack = Math.floor(Math.random() * state.playlist.length);
      } else {
        nextTrack = state.currentTrack + 1;
        if (nextTrack >= state.playlist.length) {
          if (state.repeat === 'all') {
            nextTrack = 0;
          } else {
            nextTrack = state.currentTrack;
            return { ...state, isPlaying: false };
          }
        }
      }
      return {
        ...state,
        currentTrack: nextTrack
      };
    
    case 'PREVIOUS_TRACK':
      let prevTrack;
      if (state.shuffle) {
        prevTrack = Math.floor(Math.random() * state.playlist.length);
      } else {
        prevTrack = state.currentTrack - 1;
        if (prevTrack < 0) {
          if (state.repeat === 'all') {
            prevTrack = state.playlist.length - 1;
          } else {
            prevTrack = 0;
          }
        }
      }
      return {
        ...state,
        currentTrack: prevTrack
      };
    
    case 'SET_VOLUME':
      return {
        ...state,
        volume: action.volume
      };
    
    case 'TOGGLE_SHUFFLE':
      return {
        ...state,
        shuffle: !state.shuffle
      };
    
    case 'SET_REPEAT':
      const repeatModes = ['none', 'one', 'all'];
      const currentIndex = repeatModes.indexOf(state.repeat);
      const nextIndex = (currentIndex + 1) % repeatModes.length;
      return {
        ...state,
        repeat: repeatModes[nextIndex]
      };
    
    default:
      return state;
  }
}

function MusicPlayer() {
  const [state, dispatch] = useReducer(playerReducer, initialState);
  
  const currentSong = state.playlist[state.currentTrack];
  
  const togglePlay = () => {
    if (state.isPlaying) {
      dispatch({ type: 'PAUSE' });
    } else {
      dispatch({ type: 'PLAY' });
    }
  };
  
  const nextTrack = () => {
    dispatch({ type: 'NEXT_TRACK' });
  };
  
  const previousTrack = () => {
    dispatch({ type: 'PREVIOUS_TRACK' });
  };
  
  const setVolume = (volume) => {
    dispatch({ type: 'SET_VOLUME', volume });
  };
  
  const toggleShuffle = () => {
    dispatch({ type: 'TOGGLE_SHUFFLE' });
  };
  
  const setRepeat = () => {
    dispatch({ type: 'SET_REPEAT' });
  };
  
  return (
    <div style={{ padding: '20px', border: '1px solid #ccc', maxWidth: '400px' }}>
      <h2>음악 플레이어</h2>
      
      {/* 현재 재생 중인 곡 */}
      <div style={{ textAlign: 'center', margin: '20px 0' }}>
        <h3>{currentSong.title}</h3>
        <p>{currentSong.artist}</p>
        <p>상태: {state.isPlaying ? '재생 중' : '일시정지'}</p>
      </div>
      
      {/* 컨트롤 버튼 */}
      <div style={{ textAlign: 'center', margin: '20px 0' }}>
        <button onClick={previousTrack}>⏮️</button>
        <button onClick={togglePlay} style={{ margin: '0 10px' }}>
          {state.isPlaying ? '⏸️' : '▶️'}
        </button>
        <button onClick={nextTrack}>⏭️</button>
      </div>
      
      {/* 볼륨 조절 */}
      <div style={{ margin: '20px 0' }}>
        <label>볼륨: {state.volume}%</label>
        <input
          type="range"
          min="0"
          max="100"
          value={state.volume}
          onChange={(e) => setVolume(parseInt(e.target.value))}
          style={{ width: '100%' }}
        />
      </div>
      
      {/* 추가 옵션 */}
      <div style={{ margin: '20px 0' }}>
        <button
          onClick={toggleShuffle}
          style={{ backgroundColor: state.shuffle ? '#ccc' : 'white' }}
        >
          🔀 셔플
        </button>
        <button onClick={setRepeat} style={{ marginLeft: '10px' }}>
          {state.repeat === 'none' && '🔁 반복 없음'}
          {state.repeat === 'one' && '🔂 한 곡 반복'}
          {state.repeat === 'all' && '🔁 전체 반복'}
        </button>
      </div>
      
      {/* 플레이리스트 */}
      <div>
        <h4>플레이리스트</h4>
        <ul style={{ listStyle: 'none', padding: 0 }}>
          {state.playlist.map((song, index) => (
            <li
              key={song.id}
              style={{
                padding: '5px',
                backgroundColor: index === state.currentTrack ? '#e6f3ff' : 'white',
                border: '1px solid #ddd',
                margin: '2px 0'
              }}
            >
              {song.title} - {song.artist}
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
}
```
