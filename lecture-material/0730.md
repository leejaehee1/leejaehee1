
## ✅ 『소프트웨어 아키텍처 101』 요약

### 1. 📌 소프트웨어 아키텍처란?

* 시스템의 **구조와 설계 원칙**, 그리고 **중요한 설계 결정**을 포함함.
* 시스템 품질 속성(확장성, 안정성, 성능 등)에 직접적인 영향을 미치는 **비기능적 결정들**이 핵심이다.
* 아키텍처는 **코드보다 상위 수준의 개념**이며, 개발자가 아닌 이해관계자에게도 영향을 줌.

---

### 2. ⚖️ 아키텍처 의사결정의 본질

* “**Trade-off를 이해하고 선택하는 일**”이 아키텍처의 핵심.
* 모든 선택에는 장단점이 있으며, 중요한 것은 **의사결정의 근거와 정당성**.
* 예: 모놀리식 vs 마이크로서비스 → 정답은 없으며 상황에 따라 다름.

---

### 3. 🔧 아키텍처 스타일

#### - 모놀리식 (Monolithic)

* 장점: 배포가 단순, 개발 속도 빠름
* 단점: 코드 복잡도 증가, 확장/유지보수 어려움

#### - 마이크로서비스 (Microservices)

* 장점: 독립 배포, 팀 분산 가능, 확장성 우수
* 단점: 복잡한 배포 파이프라인, 트랜잭션 관리 어려움

#### - 이벤트 기반 (Event-Driven)

* 장점: 비동기 처리, 높은 확장성
* 단점: 디버깅 어려움, 데이터 일관성 유지 문제

---

### 4. 🧩 서비스 분할 전략

* 기능적 분할 (기능 단위로 나누기)
* 도메인 중심 설계 (DDD 기반)
* 팀 구조 기반 (Conway’s Law 반영)
* 데이터 소유권 기준

---

### 5. 🔐 트랜잭션과 일관성

* 분산 시스템에서는 \*\*ACID보다 Eventually Consistent(최종 일관성)\*\*이 현실적
* Saga 패턴, 보상 트랜잭션 등으로 해결
* CAP 이론 이해: **일관성(Consistency), 가용성(Availability), 파티션 허용성(Partition tolerance)** 중 2개만 보장 가능

---

### 6. 🔄 분산 아키텍처의 문제와 해법

* **분산 트레이싱, 로깅, 장애 복구, 배포 자동화** 등 추가적인 기술적 고려 필요
* **폴리글랏 아키텍처** (여러 언어, 데이터 저장소 혼합)도 아키텍트의 책임 범위

---

### 7. 🧠 아키텍트의 역할

* 기술적 결정자뿐만 아니라 **조율자, 커뮤니케이터, 문서화 담당자**
* 팀 간 경계 명확화, 기술 부채 관리, 적절한 의사결정 기록이 중요

---

### 8. 📘 실무 팁 & 베스트 프랙티스

* 아키텍처 결정을 기록하는 **ADR(Architecture Decision Record)** 활용
* 기술 스택은 유연하게, 변화에 열려 있어야 함
* **"기술적 결정을 늦출 수 있으면 늦춰라 (Just-in-Time Decision)"** — 상황이 명확해졌을 때 결정하라

---

## 📎 결론

『소프트웨어 아키텍처 101』은 단순한 이론서가 아니라 **실제 시스템 설계에서 무엇을 고민하고 어떻게 선택해야 하는지**를 다룹니다. 핵심은 "무엇이 옳은가?"보다 \*\*"왜 그 선택을 했는가?"\*\*에 대한 논리와 책임입니다.

---

## 🧱 계층형 아키텍처(Layered Architecture) 요약

### ✅ 정의

* **기능에 따라 논리적으로 계층을 나누고**, 각 계층이 **자신보다 바로 아래 계층에만 의존**하도록 구성된 아키텍처 스타일.
* “**수직적 구조**”로, 계층 간 **의존성과 책임 분리가 명확**한 것이 특징.

---

### 📐 전형적인 계층 구조 (4계층 예시)

| 계층                        | 설명                   | 대표 구성요소                       |
| ------------------------- | -------------------- | ----------------------------- |
| **Presentation Layer**    | 사용자 인터페이스 처리         | React, Flutter, HTML/CSS, JSP |
| **Application Layer**     | 애플리케이션 흐름 제어, 서비스 조합 | Controller, Service           |
| **Domain/Business Layer** | 핵심 비즈니스 로직           | Domain Model, Business Rules  |
| **Data Access Layer**     | 데이터베이스와의 통신 담당       | DAO, Repository, ORM          |

※ 일부 아키텍처에서는 Application과 Domain 계층을 합치기도 함.

---

### 🔗 계층 간 의존성

* 상위 계층은 하위 계층에 **의존**하되, 하위 계층은 상위 계층을 **몰라야** 함.
* 예: Presentation → Application → Domain → DataAccess

---

### 🎯 장점

* **높은 응집도**, **낮은 결합도**: 계층별로 관심사 분리
* 유지보수 용이: 특정 계층만 수정해도 전체 영향 최소화
* 테스트와 디버깅 용이: 계층 단위 테스트 가능
* 팀 분업에 유리: 각 계층을 별도 팀이 담당 가능

---

### ⚠️ 단점

* 상위 계층이 하위 계층에 **강하게 결합**되어 있어 유연성이 떨어질 수 있음
* **지나친 계층화**는 오히려 복잡도 증가 및 성능 저하
* **Cross-cutting concerns**(로깅, 보안 등)을 처리하기 어려움 → AOP 등의 기술 필요
* 모든 요청이 하위 계층까지 **직렬로 흐르므로** 불필요한 호출 가능성 있음

---

### 🧰 계층형 아키텍처 적용 예시

* Java Spring MVC
* .NET 기반 애플리케이션
* Android 앱 (MVVM도 계층화 구조 기반)
* 대부분의 웹 애플리케이션 초기 구조

---

### 🏗️ 계층형 아키텍처와 클린 아키텍처 차이

| 항목              | 계층형 아키텍처       | 클린 아키텍처       |
| --------------- | -------------- | ------------- |
| **의존성 방향**      | 상위 → 하위        | 바깥 → 안쪽 (역전)  |
| **중심**          | 기술(데이터베이스, UI) | 도메인(비즈니스 규칙)  |
| **의존성 역전(DIP)** | 없음             | 있음 (인터페이스 분리) |

---

## ✅ 요약 한 줄로

> 계층형 아키텍처는 **역할에 따라 코드를 구조화하고**, **각 계층 간 책임을 분리하여 유지보수를 쉽게 하는 고전적인 아키텍처 스타일**입니다.

---

## 📣 이벤트 기반 아키텍처(Event-Driven Architecture) 요약

### ✅ 개념 정의

> \*\*이벤트(event)\*\*를 중심으로 컴포넌트들이 **비동기적으로 통신**하는 아키텍처 스타일.
> 즉, 어떤 \*\*상태 변화나 동작이 발생하면 이벤트를 발행(publish)\*\*하고, 이를 \*\*청취(subscribe)\*\*하는 컴포넌트가 해당 이벤트에 반응하여 동작합니다.

---

### 🧱 주요 구성 요소

| 구성 요소                     | 설명                                               |
| ------------------------- | ------------------------------------------------ |
| **Producer (발행자)**        | 이벤트를 생성하여 발행하는 컴포넌트. 예: 주문 생성                    |
| **Consumer (소비자)**        | 특정 이벤트에 반응하여 처리하는 컴포넌트. 예: 결제 처리                 |
| **Event Broker / 메시지 버스** | 이벤트를 중계하는 시스템. 예: Kafka, RabbitMQ, Redis Streams |

---

### 🔄 작동 흐름 예시

1. 사용자 주문 생성 → `OrderCreated` 이벤트 발행
2. 이벤트 브로커가 이벤트 전달
3. `InventoryService`, `EmailService` 등 관련 소비자들이 이벤트에 반응
4. 각각의 작업 수행 (재고 차감, 이메일 발송 등)

---

### 🎯 장점

* ✅ **비동기 처리**: 높은 확장성과 반응성
* ✅ **느슨한 결합(Loosely Coupled)**: 컴포넌트 간 직접 호출 없이 이벤트로 연결됨
* ✅ **유연성 & 확장성**: 소비자를 쉽게 추가 가능
* ✅ **복잡한 워크플로우 모델링에 유리**: Saga, 프로세스 오케스트레이션

---

### ⚠️ 단점

* ❌ **디버깅과 추적 어려움**: 이벤트 흐름이 눈에 안 보임 → 분산 트레이싱 필요
* ❌ **데이터 일관성 보장 어려움**: Eventually Consistent, 트랜잭션 관리 어려움
* ❌ **설계 복잡도 증가**: 메시지 손실, 중복 수신, 순서 보장 등 고려할 점 많음
* ❌ **테스트 난이도 상승**: 단위 테스트보다 통합 테스트 비중 커짐

---

### 🔁 패턴 유형

| 유형                               | 설명                       |
| -------------------------------- | ------------------------ |
| **Event Notification**           | "이런 일이 발생했어!" – 반응은 각자   |
| **Event-Carried State Transfer** | 이벤트에 관련 데이터도 함께 전달       |
| **Event Sourcing**               | 상태를 이벤트 로그로 저장하고 복원      |
| **CQRS + Event Sourcing**        | 읽기/쓰기 모델 분리 + 이벤트로 상태 저장 |

---

### 🧰 대표 기술 스택

* **이벤트 브로커**: Apache Kafka, RabbitMQ, Amazon SNS/SQS, NATS
* **프로그래밍 모델**: Node.js (비동기 기반), Spring Cloud Stream, NestJS, Akka, Axon
* **분산 추적 도구**: Zipkin, Jaeger

---

### 🧠 실무 활용 예시

* **쇼핑몰 주문 처리 시스템**
* **마이크로서비스 간 워크플로우**
* **IoT 센서 이벤트 수집**
* **로그 및 모니터링 시스템**

---

## ✅ 요약 한 줄로

> 이벤트 기반 아키텍처는 \*\*비동기 메시지(Event)\*\*를 통해 시스템 구성요소 간의 **의존성을 최소화하면서도 유연하게 통합**할 수 있는 아키텍처입니다.
